#Minimum Window Substring
给定两个字符串s和t，求出在s中包含t的所有字符的最小窗口。包含中的注意的细节：  
1、s中的符合要求的子串，字符顺序可以和t中的字符顺序不同，只要包含即可。  
2、t中重复出现的字符，在s中的最小窗口中也必须重复出现。  

##算法思想
1、利用need[128]保存t中个个字符出现的次数。之所以大小是128,是因为字符的ASCII的范围在0-127之间。  
2、利用candidate[128]保存在遍历s过程中，各个字符出现的次数。  
3、维持两个指针left= 0，right=0用于遍历s，在遍历过程中利用count保存同时在s和t中都出现的字符的个数。  
4、如果，count等于t的字符个数，说明在left到right中包含了t中的所有字符，由于left所指向的字符是从0开始的。还需要把left移到第一次出现t中字符的位置。  

##时间复杂度和空间复杂度
空间复杂度是O(1)：只需要常数的空间。  
时间复杂度O(n):n是字符串s的长度。

##前一个包含所有t字符的s的一个子串，如何滑到后一个包含t所有字符的s的子串
while(left < right)  
{  
    int tmp = (int)s[left];  
    if(candidate[tmp] > need[tmp])  
        candidate[tmp]--;  
        left++;  
}  
